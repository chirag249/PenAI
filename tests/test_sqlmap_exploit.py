# tests/test_sqlmap_exploit.py
import asyncio
import json
import types
import os
import tempfile
import pytest

# the module we added
from modules.destructive import sqlmap_exploit


class DummyScope:
    def __init__(self, targets, destructive_allowed=True):
        self.targets = targets
        self._destructive_allowed = destructive_allowed

    def is_destructive_allowed(self, outdir):
        return self._destructive_allowed


def fake_run_tool_success(tool_name, outdir, target=None, extra_args=None, timeout=None):
    """
    Simulate run_tool returning a dict that the exploit adapter expects.
    Provide stdout containing 'current user' to trigger heuristic parsing.
    """
    return {
        "tool": tool_name,
        "status": "ran",
        "stdout": "Current user: www-data\nAvailable databases: db1, db2",
        "stderr": "",
        "result": {"mock": True},
    }


def fake_run_tool_no_stdout(tool_name, outdir, target=None, extra_args=None, timeout=None):
    return {
        "tool": tool_name,
        "status": "ran",
        "stdout": "",
        "stderr": "no useful output",
        "result": {"mock": True},
    }


@pytest.mark.asyncio
async def test_run_sqlmap_exploit_skipped_when_not_allowed(tmp_path, monkeypatch):
    outdir = str(tmp_path)
    scope = DummyScope(["https://example.com"], destructive_allowed=False)

    # Ensure that when destructive is not allowed, nothing runs
    findings = await sqlmap_exploit.run_sqlmap_exploit(scope, outdir)
    assert isinstance(findings, list)
    assert findings == []


@pytest.mark.asyncio
async def test_run_sqlmap_exploit_parses_stdout_success(tmp_path, monkeypatch):
    outdir = str(tmp_path)
    scope = DummyScope(["https://example.com"], destructive_allowed=True)

    # Monkeypatch the run_tool reference inside the module to our fake
    monkeypatch.setattr(sqlmap_exploit, "run_tool", fake_run_tool_success)

    findings = await sqlmap_exploit.run_sqlmap_exploit(scope, outdir)

    assert isinstance(findings, list)
    assert len(findings) >= 1
    # heuristics should detect "current user" and mark severity high
    found_types = {f["type"] for f in findings}
    assert "rce-sqlmap-info" in found_types or "sqli-database-enum" in found_types or "sqli-external-sqlmap" in found_types
    # evidence should include the stdout snippet
    assert any("Current user" in f["evidence"] or "current user" in f["evidence"].lower() for f in findings)


@pytest.mark.asyncio
async def test_run_sqlmap_exploit_fallback_when_no_stdout(tmp_path, monkeypatch):
    outdir = str(tmp_path)
    scope = DummyScope(["https://example.com"], destructive_allowed=True)

    monkeypatch.setattr(sqlmap_exploit, "run_tool", fake_run_tool_no_stdout)

    findings = await sqlmap_exploit.run_sqlmap_exploit(scope, outdir)
    assert isinstance(findings, list)
    assert len(findings) == 1
    assert findings[0]["type"] in ("sqli-external-sqlmap",)
    assert "no useful output" in findings[0]["evidence"] or findings[0]["evidence"]


