#!/usr/bin/env python3
# modules/destructive/sqlmap_exploit.py
from __future__ import annotations
import asyncio
import logging
from typing import List, Dict, Any, Optional

logger = logging.getLogger(__name__)

# expose name for tests to monkeypatch
run_tool = None
try:
    from modules.tools.manager import run_tool  # type: ignore
except Exception:
    run_tool = None  # keep symbol present for monkeypatching


async def run_sqlmap_exploit(scope, outdir: str) -> List[Dict[str, Any]]:
    """
    Run sqlmap in exploit-style mode (only when allowed) and return findings list.
    """
    findings: List[Dict[str, Any]] = []

    # safety gate
    try:
        if not scope.is_destructive_allowed(outdir):
            logger.warning("Destructive sqlmap exploit skipped: scope.is_destructive_allowed == False")
            return findings
    except Exception:
        logger.exception("Destructive sqlmap exploit: failed to check scope; aborting")
        return findings

    target = (scope.targets[0] if isinstance(scope.targets, (list, tuple)) and scope.targets else (scope.targets if isinstance(scope.targets, str) else None)) or None
    if target is None:
        logger.warning("No target available for sqlmap exploit")
        return findings

    logger.warning("Running destructive sqlmap adapter against %s (exploit mode).", target)

    extra_args = [
        "--batch",
        "--risk=2",
        "--level=2",
        "--random-agent",
        "--banner",
        "--current-db",
        "--current-user",
        "--threads=2",
    ]

    if run_tool is None:
        logger.error("modules.tools.manager.run_tool not available â€” cannot run sqlmap exploit")
        return findings

    try:
        res = await asyncio.to_thread(run_tool, "sqlmap", outdir, target, extra_args, None)
    except Exception as e:
        logger.exception("sqlmap exploit run_tool raised: %s", e)
        return findings

    # Extract outputs from both nested result and top-level keys (tests monkeypatch top-level)
    stdout = ""
    stderr = ""
    result_blob = res if not isinstance(res, dict) else (res.get("result") or res)

    if isinstance(res, dict):
        result = res.get("result") or {}
        stdout = str(result.get("stdout") or res.get("stdout") or "")
        stderr = str(result.get("stderr") or res.get("stderr") or "")
        vulns = result.get("vulnerabilities") or res.get("vulnerabilities") or None
    else:
        vulns = None

    # If parsed vulnerabilities are present, normalize them
    if isinstance(vulns, list) and vulns:
        for v in vulns:
            findings.append({
                "type": "sqli-external-sqlmap",
                "target": v.get("url") or target,
                "severity": v.get("confidence") or 5,
                "evidence": v,
                "source": {"tool": "sqlmap", "mode": "exploit"},
            })
        return findings

    # Heuristic: scan stdout for keywords
    combined = (stdout + "\n" + stderr).lower()
    if combined:
        if "current user" in combined or "current-user" in combined:
            findings.append({
                "type": "rce-sqlmap-info",
                "target": target,
                "severity": 5,
                "evidence": (stdout or stderr)[:4000],
                "source": {"tool": "sqlmap", "mode": "exploit", "raw": result_blob},
            })
        elif "available databases" in combined or "current database" in combined:
            findings.append({
                "type": "sqli-database-enum",
                "target": target,
                "severity": 5,
                "evidence": (stdout or stderr)[:4000],
                "source": {"tool": "sqlmap", "mode": "exploit", "raw": result_blob},
            })

    # Default: package envelope as single finding if nothing else
    if not findings:
        findings.append({
            "type": "sqli-external-sqlmap",
            "target": target,
            "severity": 4,
            "evidence": (stdout or stderr)[:4000] or str(result_blob)[:4000],
            "source": {"tool": "sqlmap", "mode": "exploit", "raw": result_blob},
        })

    logger.info("sqlmap exploit produced %d findings", len(findings))
    return findings
